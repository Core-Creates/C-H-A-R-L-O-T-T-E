import os
import time
from typing import Dict, Optional, Tuple
import requests


DEFAULT_ZAP_HOST = os.getenv("ZAP_HOST", "127.0.0.1")
DEFAULT_TARGET = os.getenv("ZAP_TARGET", "https://public-firing-range.appspot.com")
DEFAULT_ZAP_PORT = int(os.getenv("ZAP_PORT", "8080"))
DEFAULT_API_KEY = os.getenv("ZAP_API_KEY", "")  # empty means API key not enforced on server side
DEFAULT_TIMEOUT = float(os.getenv("ZAP_HTTP_TIMEOUT", "5.0"))
DEFAULT_SCAN_TIMEOUT = int(os.getenv("ZAP_SCAN_TIMEOUT_SECONDS", "900"))  # 15 minutes max per scan phase
POLL_INTERVAL = float(os.getenv("ZAP_POLL_INTERVAL", "2.0"))


def _zap_base(zap_host: str, zap_port: int) -> str:
    # ZAP API is served on the same port as the proxy by default
    return f"http://{zap_host}:{zap_port}"


def _zap_get(endpoint: str, params: Dict, timeout: float) -> requests.Response:
    return requests.get(endpoint, params=params, timeout=timeout)


def _require_ok(resp: requests.Response) -> Dict:
    resp.raise_for_status()
    data = resp.json()
    # ZAP API always returns JSON objects; some actions return {"scan": "ID"} etc.
    return data


def _check_zap_connection(zap_host: str, zap_port: int, timeout: float) -> Tuple[bool, Optional[str]]:
    """
    Try to fetch ZAP version. Returns (ok, error_message_if_any).
    """
    base = _zap_base(zap_host, zap_port)
    url = f"{base}/JSON/core/view/version/"
    try:
        r = _zap_get(url, {}, timeout)
        r.raise_for_status()
        # Expected: {"version":"D-<date>"} or similar
        _ = r.json()
        return True, None
    except requests.exceptions.ConnectionError as ce:
        return False, f"Cannot connect to OWASP ZAP at {zap_host}:{zap_port} (connection refused). Is ZAP running and reachable?"
    except requests.exceptions.Timeout:
        return False, f"Timed out connecting to OWASP ZAP at {zap_host}:{zap_port}. Check host/port/firewall."
    except Exception as e:
        return False, f"Unexpected error connecting to ZAP at {zap_host}:{zap_port}: {e}"


def _zap_action(base: str, path: str, api_key: str, params: Dict, timeout: float) -> Dict:
    url = f"{base}{path}"
    payload = dict(params or {})
    if api_key:
        payload["apikey"] = api_key
    resp = _zap_get(url, payload, timeout)
    return _require_ok(resp)


def _zap_view(base: str, path: str, api_key: str, params: Dict, timeout: float) -> Dict:
    url = f"{base}{path}"
    payload = dict(params or {})
    if api_key:
        payload["apikey"] = api_key
    resp = _zap_get(url, payload, timeout)
    return _require_ok(resp)


def _wait_for_spider(base: str, api_key: str, scan_id: str, timeout_seconds: int) -> bool:
    """
    Polls spider status until 100% or timeout. Returns True if completed, False if timed out.
    """
    end = time.time() + timeout_seconds
    while time.time() < end:
        data = _zap_view(base, "/JSON/spider/view/status/", api_key, {"scanId": scan_id}, DEFAULT_TIMEOUT)
        status_str = data.get("status", "0")
        try:
            status = int(status_str)
        except ValueError:
            status = 0
        if status >= 100:
            return True
        time.sleep(POLL_INTERVAL)
    return False


def _wait_for_pscan(base: str, api_key: str, timeout_seconds: int) -> bool:
    """
    Waits until passive scanner has no more records to scan, or timeout.
    """
    end = time.time() + timeout_seconds
    last_remaining = -1  # Initialize to track changes
    while time.time() < end:
        try:
            data = _zap_view(base, "/JSON/pscan/view/recordsToScan/", api_key, {}, DEFAULT_TIMEOUT)
            remaining_str = data.get("recordsToScan", "0")
            try:
                remaining = int(remaining_str)
                if remaining != last_remaining:
                    print(f"[OWASP ZAP] Passive scan: {remaining} records remaining")
                    last_remaining = remaining
            except ValueError:
                print(f"[OWASP ZAP] Warning: Invalid passive scan response: {remaining_str}")
                remaining = 0
            if remaining <= 0:
                return True
        except Exception as e:
            print(f"[OWASP ZAP] Warning: Error checking passive scan status: {e}")
        time.sleep(POLL_INTERVAL)
    return False


def _summarize_alerts(alerts: Dict) -> str:
    """
    Alerts format: {"alerts": [ {... "risk": "High", ...}, ... ]}
    Summarize counts by risk and return a human-readable string.
    """
    items = alerts.get("alerts", []) or []
    by_risk = {"High": 0, "Medium": 0, "Low": 0, "Informational": 0}
    for a in items:
        risk = a.get("risk", "Informational")
        if risk not in by_risk:
            by_risk[risk] = 0
        by_risk[risk] += 1

    lines = [
        "OWASP ZAP Scan Summary",
        f"  High          : {by_risk.get('High', 0)}",
        f"  Medium        : {by_risk.get('Medium', 0)}",
        f"  Low           : {by_risk.get('Low', 0)}",
        f"  Informational : {by_risk.get('Informational', 0)}",
        f"  Total Alerts  : {len(items)}",
    ]
    return "\n".join(lines)


def run(args: Optional[Dict] = None) -> str:
    """
    Entry point used by plugin_manager. Performs a spider + passive scan and reports alerts.
    args:
      - target (required): URL to scan. Default: https://public-firing-range.appspot.com
      - zap_host (optional): default 127.0.0.1
      - zap_port (optional): default 8080
      - api_key (optional): default from env ZAP_API_KEY
      - http_timeout (optional): float seconds for single HTTP call (default 5.0)
      - scan_timeout (optional): int seconds for each wait phase (default 900)
    """
    try:
        args = args or {}
        target = args.get("target", DEFAULT_TARGET)
        zap_host = args.get("zap_host", DEFAULT_ZAP_HOST)
        zap_port = int(args.get("zap_port", DEFAULT_ZAP_PORT))
        api_key = args.get("api_key", DEFAULT_API_KEY)
        http_timeout = float(args.get("http_timeout", DEFAULT_TIMEOUT))
        scan_timeout = int(args.get("scan_timeout", DEFAULT_SCAN_TIMEOUT))

        print(f"[OWASP ZAP] Starting scan of {target}")
        print(f"[OWASP ZAP] Connecting to ZAP at {zap_host}:{zap_port}")

        ok, err = _check_zap_connection(zap_host, zap_port, http_timeout)
        if not ok:
            return (
                f"[OWASP ZAP] {err}\n\n"
                "How to fix:\n"
                f"- Start ZAP (GUI or daemon) and ensure it's listening on {zap_host}:{zap_port}.\n"
                "- If API key is enabled in ZAP, set environment variable ZAP_API_KEY or pass args['api_key'].\n"
                "- Verify local firewall and that your client IP is allowed in ZAP API settings."
            )

        base = _zap_base(zap_host, zap_port)

        # Start spider scan
        try:
            spider_resp = _zap_action(
                base,
                "/JSON/spider/action/scan/",
                api_key,
                {"url": target, "recurse": "true"},
                http_timeout,
            )
        except Exception as e:
            return f"[OWASP ZAP] Failed to start spider scan: {e}"

        scan_id = str(spider_resp.get("scan", ""))
        if not scan_id:
            return f"[OWASP ZAP] Spider scan did not return a scan ID. Response: {spider_resp}"

        print(f"[OWASP ZAP] Spider scan started with ID: {scan_id}")
        print(f"[OWASP ZAP] Waiting for spider completion...")

        # Wait for spider completion
        if not _wait_for_spider(base, api_key, scan_id, scan_timeout):
            return f"[OWASP ZAP] Spider scan timed out after {scan_timeout}s."

        print("[OWASP ZAP] Spider scan completed")
        print("[OWASP ZAP] Waiting for passive scan completion...")

        # Wait for passive scan to complete
        if not _wait_for_pscan(base, api_key, scan_timeout):
            return f"[OWASP ZAP] Passive scan did not complete within {scan_timeout}s."

        print("[OWASP ZAP] Passive scan completed")
        print("[OWASP ZAP] Fetching scan results...")

        # Fetch alerts
        try:
            alerts = _zap_view(
                base,
                "/JSON/core/view/alerts/",
                api_key,
                {"baseurl": target},
                http_timeout,
            )
        except Exception as e:
            return f"[OWASP ZAP] Failed to fetch alerts: {e}"

        summary = _summarize_alerts(alerts)
        print("[OWASP ZAP] Scan completed successfully!")
        print(f"\n{summary}")
        return summary
        
    except Exception as e:
        return f"[OWASP ZAP] Error: {e}"


if __name__ == "__main__":
    try:
        summary = run({
            "target": DEFAULT_TARGET,
        })
        print(f'[OWASP ZAP] Scan summary:\n{summary}')
    except Exception as e:
        print(f'[OWASP ZAP] Error: {e}')
