"""
CHARLOTTE Metasploit plugin package.

This package provides a thin, lazy-loading faÃ§ade around the actual implementation
in `metasploit_plugin.py`. Import cost stays minimal until a function is called.

Exposed entrypoints (used by the CHARLOTTE plugin manager):
- run(args=None):         primary dynamic-plugin entrypoint
- run_plugin(args=None):  alias for environments expecting `run_plugin`

Convenience passthroughs:
- execute_chained_cve(client, cve, rhost, lhost, lport)
- auto_execute_exploit(client, exploit_name, rhost, lhost, lport)
- interactive_exploit_demo(client)
- connect_to_msf(port=None)
- start_msfrpcd(port)
- find_available_port()
"""

from __future__ import annotations

from importlib import import_module
from types import ModuleType
from typing import Any

__all__ = [
    "run",
    "run_plugin",
    "execute_chained_cve",
    "auto_execute_exploit",
    "interactive_exploit_demo",
    "connect_to_msf",
    "start_msfrpcd",
    "find_available_port",
    "get_plugin_spec",
]

__version__ = "0.1.0"


def _load() -> ModuleType:
    """Import and return the underlying `metasploit_plugin` module."""
    return import_module(".metasploit_plugin", package=__name__)


# ----------------------------- Entry points -----------------------------


def run(args: dict[str, Any] | None = None) -> Any:
    """
    Primary dynamic-plugin entrypoint.

    Accepts optional `args` including (but not limited to):
      - action: "interactive" | "auto" | "chain"
      - exploit, cve/cve_id, rhost/target, lhost, lport, chain_input
    """
    return _load().run(args)


def run_plugin(args: dict[str, Any] | None = None, **kwargs: Any) -> Any:
    """Alias for environments that expect `run_plugin` instead of `run`."""
    if args is None and kwargs:
        # allow call pattern: run_plugin(exploit="...", rhost="...")
        args = dict(kwargs)
    return _load().run_plugin(args)


# --------------------------- Passthrough APIs ---------------------------


def execute_chained_cve(
    client: Any, cve: str, rhost: str, lhost: str, lport: str | int
) -> Any:
    """Passthrough to execute a CVE-driven exploit chain."""
    return _load().execute_chained_cve(client, cve, rhost, lhost, lport)


def auto_execute_exploit(
    client: Any, exploit_name: str, rhost: str, lhost: str, lport: str | int
) -> Any:
    """Passthrough to run a specific Metasploit exploit with parameters."""
    return _load().auto_execute_exploit(client, exploit_name, rhost, lhost, lport)


def interactive_exploit_demo(client: Any) -> Any:
    """Passthrough to the interactive demonstration flow."""
    return _load().interactive_exploit_demo(client)


def connect_to_msf(port: int | None = None) -> Any:
    """Passthrough to establish an RPC connection to Metasploit."""
    return _load().connect_to_msf(port)


def start_msfrpcd(port: int) -> bool:
    """Passthrough to start msfrpcd on the given port."""
    return _load().start_msfrpcd(port)


def find_available_port() -> int:
    """Passthrough to find an available TCP port for msfrpcd."""
    return _load().find_available_port()


# ----------------------- Optional discovery helper ----------------------


def get_plugin_spec() -> dict[str, Any]:
    """
    Optional helper for loaders that support in-code discovery
    (most setups use plugin.yaml; this is just a convenience).
    """
    return {
        "label": "metasploit_exploit",
        "pretty_name": "Metasploit Exploit",
        "description": "Launch Metasploit modules via RPC; supports CVE chaining.",
        "module": "plugins.exploitation.metasploit.metasploit_plugin",
        "entrypoint": "run",
        "categories": ["exploitation"],
        "tags": ["metasploit", "cve", "rpc"],
        "version": __version__,
    }
