# ******************************************************************************************
# msf_mapper.py
# Utility for mapping CVE IDs to Metasploit modules via RPC client
# Adds caching, confidence scores, and enrichment with auxiliary/post modules
# ******************************************************************************************

import difflib

# In-memory cache to prevent duplicate RPC calls
_cve_cache = {}

# ==========================================================================================
# FUNCTION: compute_confidence_score()
# Calculates similarity ratio between CVE ID and module references or name
# ==========================================================================================
def compute_confidence_score(cve_id, module_entry):
    keys_to_check = [module_entry.get("fullname", ""), module_entry.get("name", "")]
    refs = module_entry.get("references", []) or []
    keys_to_check.extend(refs)

    best_score = 0.0
    for key in keys_to_check:
        score = difflib.SequenceMatcher(None, cve_id.lower(), key.lower()).ratio()
        if score > best_score:
            best_score = score
    return round(best_score, 2)

# ==========================================================================================
# FUNCTION: find_exploit_for_cve()
# Attempts to match a CVE ID to Metasploit modules (exploit, auxiliary, post)
# ==========================================================================================
def find_exploit_for_cve(client, cve_id):
    if cve_id in _cve_cache:
        print(f"[*] Retrieved {cve_id} from cache.")
        return _cve_cache[cve_id]

    print(f"[*] Searching Metasploit modules for {cve_id}...")
    results = client.modules.search(cve_id)

    exploits = []
    auxiliary = []
    post = []

    for r in results:
        score = compute_confidence_score(cve_id, r)
        mod_entry = {"name": r["fullname"], "score": score}

        if r["type"] == "exploit":
            exploits.append(mod_entry)
        elif r["type"] == "auxiliary":
            auxiliary.append(mod_entry)
        elif r["type"] == "post":
            post.append(mod_entry)

    # Sort by descending confidence
    exploits.sort(key=lambda x: x["score"], reverse=True)
    auxiliary.sort(key=lambda x: x["score"], reverse=True)
    post.sort(key=lambda x: x["score"], reverse=True)

    result = {
        "exploits": exploits,
        "auxiliary": auxiliary,
        "post": post
    }

    if exploits:
        print(f"[+] Exploit modules found: {[x['name'] for x in exploits]}")
    else:
        print(f"[!] No direct exploits found for {cve_id}.")
        if auxiliary:
            print(f"[*] Auxiliary modules found: {[x['name'] for x in auxiliary]}")
        if post:
            print(f"[*] Post-exploitation modules found: {[x['name'] for x in post]}")

    _cve_cache[cve_id] = result
    return result
