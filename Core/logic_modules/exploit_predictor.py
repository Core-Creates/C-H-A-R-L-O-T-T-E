# ******************************************************************************************
# exploit_predictor.py - Predicts exploitability of vulnerabilities
# Based on CVSS scores, impact type, known exploit databases, and metadata heuristics
# Can be used in tandem with triage_agent.py for severity and action prioritization
# ******************************************************************************************

import json
import random
import logging

# Optional: for colorful CLI output
try:
    from colorama import Fore, Style
    COLORAMA_AVAILABLE = True
except ImportError:
    COLORAMA_AVAILABLE = False

# Logging setup
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

# ------------------------------------------------------------------------------------------
# FUNCTION: color_prediction()
# Optional CLI output colorizer for prediction labels
# ------------------------------------------------------------------------------------------
def color_prediction(prediction):
    if not COLORAMA_AVAILABLE:
        return prediction

    if prediction == "Exploit Likely":
        return Fore.RED + prediction + Style.RESET_ALL
    elif prediction == "Exploit Possible":
        return Fore.YELLOW + prediction + Style.RESET_ALL
    else:
        return Fore.GREEN + prediction + Style.RESET_ALL

# ------------------------------------------------------------------------------------------
# FUNCTION: predict_exploitability()
# Estimates likelihood of exploitability based on available attributes
# ------------------------------------------------------------------------------------------
def predict_exploitability(vuln):
    """
    Predict whether an exploit exists or is likely based on known features.

    Args:
        vuln (dict): A dictionary containing vulnerability data.

    Returns:
        dict: Updated dictionary with 'exploit_prediction' and 'confidence' fields.
    """
    score = 0
    reasons = []

    # 1. CVSS score
    cvss = vuln.get("cvss", 0)
    if cvss >= 9:
        score += 3
        reasons.append("High CVSS")
    elif cvss >= 7:
        score += 2
        reasons.append("Medium CVSS")

    # 2. Impact type
    impact = vuln.get("impact", "").lower()
    if "rce" in impact or "remote code" in impact:
        score += 3
        reasons.append("RCE detected")
    elif "privilege escalation" in impact or "pe" in impact:
        score += 2
        reasons.append("Privilege escalation")

    # 3. Known exploits (boolean flag)
    if vuln.get("exploit_available", False):
        score += 4
        reasons.append("Exploit already available")

    # 4. Attack vector
    vector = vuln.get("attack_vector", "").lower()
    if "network" in vector:
        score += 2
        reasons.append("Network accessible")

    # 5. Age of CVE (older = more likely public exploit exists)
    if "cve_id" in vuln:
        try:
            year = int(vuln["cve_id"].split("-")[1])
            if year < 2022:
                score += 1
                reasons.append("Older CVE (higher chance of public exploit)")
        except Exception:
            pass

    # Final prediction threshold
    if score >= 7:
        prediction = "Exploit Likely"
    elif score >= 4:
        prediction = "Exploit Possible"
    else:
        prediction = "Exploit Unlikely"

    confidence = min(100, 50 + score * 6)

    return {
        **vuln,
        "exploit_prediction": prediction,
        "confidence": f"{confidence}%",
        "prediction_factors": reasons
    }

# ------------------------------------------------------------------------------------------
# FUNCTION: batch_predict()
# Apply exploit prediction to a list of vulnerability entries
# ------------------------------------------------------------------------------------------
def batch_predict(vuln_list):
    return [predict_exploitability(v) for v in vuln_list]

# ------------------------------------------------------------------------------------------
# Standalone CLI usage (for testing or offline prediction)
# ------------------------------------------------------------------------------------------
if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Predict exploitability of vulnerabilities.")
    parser.add_argument("file", help="Path to JSON file with vulnerability data")
    parser.add_argument("-v", "--verbose", action="store_true", help="Enable verbose output")

    args = parser.parse_args()

    try:
        with open(args.file, "r", encoding="utf-8") as f:
            data = json.load(f)
    except Exception as e:
        logger.error(f"Failed to load file: {e}")
        exit(1)

    results = batch_predict(data)

    # Verbose CLI output
    if args.verbose:
        for r in results:
            cve_id = r.get("cve_id", "UNKNOWN")
            pred = color_prediction(r["exploit_prediction"])
            conf = r["confidence"]
            print(f"[{cve_id}] â†’ {pred} ({conf})")
            print("  Reasons: " + "; ".join(r["prediction_factors"]))
            print()

    # Default: output JSON
    else:
        print(json.dumps(results, indent=4))

    logger.info("Exploitability prediction completed.")
    exit(0)
# ------------------------------------------------------------------------------------------
# End of exploit_predictor.py